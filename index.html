<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCStructure Analyzer &amp; 3D Visualizer</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load OrbitControls for camera interaction -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Load TGALoader for TGA textures -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/TGALoader.js"></script>
    <!-- BufferGeometryUtils for merging geometries to reduce draw calls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
    <!-- Load JSZip for user-provided Bedrock packs -->
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <!-- Load Pako for Gzip decompression (Required for Step 1) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
        /* Custom styles for better aesthetics and layout */
        body { font-family: 'Inter', sans-serif; background-color: #f7f9fb; }
        .grid-container {
            display: grid;
            grid-template-columns: 1fr 300px; /* 3D view | Sidebar */
            height: calc(100vh - 80px); /* Account for header/padding */
        }
        #canvas-container {
            position: relative;
            background: linear-gradient(135deg, #1f2937, #374151); /* Dark background for 3D */
            border-radius: 0.75rem;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }
        #material-list {
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            scrollbar-width: thin;
        }
        .material-thumb {
            width: 42px;
            height: 42px;
            border-radius: 0.75rem;
            background: #f3f4f6;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border: 1px solid #e5e7eb;
        }
        .material-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            image-rendering: pixelated;
        }
        #packStatus {
            font-size: 0.85rem;
            color: #4b5563;
        }
        /* Custom Scrollbar for dark theme */
        #material-list::-webkit-scrollbar { width: 8px; }
        #material-list::-webkit-scrollbar-thumb { background-color: #6b7280; border-radius: 4px; }
        #material-list::-webkit-scrollbar-track { background-color: #1f2937; }

        /* The canvas itself will be appended here */
        canvas { display: block; }
    </style>
</head>
<body class="p-4">

    <!-- Custom Message Box for Errors and Successes (Replaces alert()) -->
    <div id="messageBox" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-6 rounded-xl shadow-2xl max-w-md w-full text-center">
            <h3 id="messageTitle" class="text-xl font-bold mb-3 text-red-600">Error</h3>
            <p id="messageText" class="text-gray-700 mb-4"></p>
            <button onclick="hideMessageBox()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-200">
                Acknowledge
            </button>
        </div>
    </div>

    <header class="mb-4 flex justify-between items-center bg-white p-4 rounded-xl shadow-lg">
        <div>
            <h1 class="text-3xl font-extrabold text-gray-800">Minecraft Structure Analyzer</h1>
            <p id="packStatus" class="mt-1">Textures: upload resource pack (.zip/.mcpack)</p>
        </div>
        <div class="flex flex-wrap gap-3 items-center">
            <input type="file" id="fileInput" accept=".mcstructure" class="hidden"> 
            <label for="fileInput" class="cursor-pointer bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-300 shadow-md hover:shadow-lg transform hover:scale-105">
                Load .mcstructure File
            </label>
            <input type="file" id="resourcePackInput" accept=".zip,.mcpack" class="hidden">
            <label for="resourcePackInput" class="cursor-pointer bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-6 rounded-lg transition duration-300 shadow-md hover:shadow-lg transform hover:scale-105">
                Load Resource Pack (.zip/.mcpack)
            </label>
        </div>
    </header>

    <main id="app-container" class="grid-container gap-4">

        <!-- 2D Top-Down Grid View for Layer Inspection -->
        <div id="layer2d-container" class="mb-4 p-2 bg-white rounded-lg shadow flex flex-col items-center">
            <div class="flex items-center gap-3 mb-2">
                <label for="layer2dInput" class="text-sm font-medium text-gray-700">2D Layer (Y):</label>
                <input id="layer2dInput" type="number" min="0" value="0" class="w-20 p-1 rounded border border-gray-300 text-sm" />
                <span id="layer2dInfo" class="text-xs text-gray-500"></span>
            </div>
            <div id="layer2d-canvas-wrap" style="position:relative; width:100%;">
                <!-- Remove fixed width/height attributes so CSS and JS can control the canvas sizing responsively -->
                <canvas id="layer2d-canvas" style="width:100%; height:100%; border:1px solid #d1d5db; background:#f3f4f6; cursor:crosshair; display:block;"></canvas>
                <div id="layer2d-tooltip" style="display:none; position:absolute; pointer-events:none; background:rgba(30,41,59,0.95); color:#fff; font-size:13px; padding:6px 10px; border-radius:8px; z-index:20; min-width:120px;"></div>
            </div>
        </div>

        <!-- 3D Visualizer Container -->
        <div id="canvas-container" class="p-2">
            <div id="loadingMessage" class="absolute inset-0 flex items-center justify-center text-white text-xl bg-gray-900 bg-opacity-80 transition duration-500 z-10 hidden">
                Parsing structure and calculating materials...
            </div>
            <div id="emptyState" class="absolute inset-0 flex items-center justify-center text-white text-xl bg-gray-800 transition duration-500 z-10">
                Upload a .mcstructure file to begin visualization.
            </div>
        </div>

        <!-- Sidebar for Controls and Material List -->
        <aside class="bg-white p-5 rounded-xl shadow-lg flex flex-col">
            <h2 class="text-xl font-bold mb-3 text-gray-700">Structure Details</h2>

            <!-- Layer Filter Controls -->
            <div id="layerControls" class="mb-5 p-3 bg-gray-50 rounded-lg border border-gray-200 hidden">
                <h3 class="font-semibold text-lg mb-2 text-gray-700">Layer Filter (Y-Axis)</h3>
                <div class="flex items-center justify-between mb-2">
                    <span class="text-sm font-medium text-gray-600">Current Layer: <span id="currentLayerDisplay">All</span></span>
                    <button id="toggleGrid" class="text-xs bg-gray-200 hover:bg-gray-300 text-gray-700 py-1 px-3 rounded-full transition">
                        Show Grid
                    </button>
                </div>

                <div class="flex gap-2 items-center mb-2">
                    <label class="flex items-center gap-2 text-sm text-gray-600"><input id="enableLayerFilter" type="checkbox" class="w-4 h-4" checked> Enable Layer Filter</label>
                    <label class="flex items-center gap-2 text-sm text-gray-600"><input id="enableMerging" type="checkbox" class="w-4 h-4" checked> Merge Geometries</label>
                    <label class="flex items-center gap-2 text-sm text-gray-600"><input id="previewModeCheckbox" type="checkbox" class="w-4 h-4"> Preview Mode (no lighting)</label>
                    <button id="showAllLayers" class="ml-auto text-xs bg-indigo-600 hover:bg-indigo-700 text-white py-1 px-3 rounded-full transition">Show All</button>
                </div>

                <div class="grid grid-cols-2 gap-2">
                    <div>
                        <label for="layerBottomInput" class="block text-xs text-gray-500">Layer Bottom</label>
                        <input id="layerBottomInput" type="number" min="0" value="0" class="w-full mt-1 p-2 rounded border border-gray-200 text-sm" />
                    </div>
                    <div>
                        <label for="layerTopInput" class="block text-xs text-gray-500">Layer Top</label>
                        <input id="layerTopInput" type="number" min="0" value="0" class="w-full mt-1 p-2 rounded border border-gray-200 text-sm" />
                    </div>
                </div>
            </div>

            <!-- Material List -->
            <h3 class="font-semibold text-lg mb-3 text-gray-700 border-t pt-3 mt-auto">Material List (64/Stack)</h3>
            <div id="material-list" class="flex-grow p-2 bg-gray-50 rounded-lg">
                <p id="materialEmpty" class="text-sm text-gray-500">Materials will appear here after loading.</p>
            </div>
        </aside>
    </main>

    <script type="module">
        // Import the parsing function. MOCK_BLOCK_DATA is now handled internally by the NBT parser mock.
        import { parseMCStructureBinary } from './nbt_parser.js';
        import { ResourcePackTextureManager } from './texture_manager.js';
        
        // --- CONSTANTS AND GLOBALS ---
        const BLOCK_SIZE = 1; 
        const STACK_SIZE = 64;
        const DEFAULT_PACK_STATUS = "Textures: upload resource pack (.zip/.mcpack)";
        const textureManager = new ResourcePackTextureManager('./resource_pack');

        let sharedCubeGeometry = null;
        // Always-available default cube geometry function
        function getSharedCubeGeometry() {
            if (!sharedCubeGeometry) {
                sharedCubeGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            }
            return sharedCubeGeometry;
        }

        // Three.js Globals
    let scene, camera, renderer, controls, blockGroup, gridHelper;
        let structureData = null;
        let maxLayer = 0;
        let currentLayer = 0;
    let isGridVisible = true;
    let overlayGrid = null; // LineSegments overlay drawn on top of blocks for counting
    // cache of preview images for each palette index (Image objects)
    const palettePreviewImages = {};


        // Custom geometries for special block types
        const geometryCache = {};
        function getBlockGeometry(blockName) {
            blockName = blockName.toLowerCase();
            // Fences
            if (blockName.includes('fence')) {
                if (!geometryCache.fence) {
                    // Thin vertical post
                    const post = new THREE.BoxGeometry(BLOCK_SIZE * 0.2, BLOCK_SIZE, BLOCK_SIZE * 0.2);
                    // Horizontal rails (2)
                    const rail = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE * 0.1, BLOCK_SIZE * 0.1);
                    rail.translate(0, BLOCK_SIZE * 0.25, 0);
                    const rail2 = rail.clone();
                    rail2.translate(0, BLOCK_SIZE * 0.5, 0);
                    // Merge
                    geometryCache.fence = THREE.BufferGeometryUtils.mergeBufferGeometries([post, rail, rail2]);
                }
                return geometryCache.fence;
            }
            // Walls
            if (blockName.includes('wall')) {
                if (!geometryCache.wall) {
                    geometryCache.wall = new THREE.BoxGeometry(BLOCK_SIZE * 0.6, BLOCK_SIZE, BLOCK_SIZE * 0.6);
                }
                return geometryCache.wall;
            }
            // Stairs
            if (blockName.includes('stair')) {
                if (!geometryCache.stair) {
                    // Simple L-shape
                    const step1 = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE * 0.5, BLOCK_SIZE * 0.5);
                    step1.translate(0, -BLOCK_SIZE * 0.25, -BLOCK_SIZE * 0.25);
                    const step2 = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE * 0.5, BLOCK_SIZE * 0.5);
                    step2.translate(0, BLOCK_SIZE * 0.25, BLOCK_SIZE * 0.25);
                    geometryCache.stair = THREE.BufferGeometryUtils.mergeBufferGeometries([step1, step2]);
                }
                return geometryCache.stair;
            }
            // Slabs
            if (blockName.includes('slab')) {
                if (!geometryCache.slab) {
                    geometryCache.slab = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE * 0.5, BLOCK_SIZE);
                    geometryCache.slab.translate(0, -BLOCK_SIZE * 0.25, 0);
                }
                return geometryCache.slab;
            }
            // Panes/Bars
            if (blockName.includes('pane') || blockName.includes('bar')) {
                if (!geometryCache.pane) {
                    geometryCache.pane = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE * 0.1);
                }
                return geometryCache.pane;
            }
            // Buttons
            if (blockName.includes('button')) {
                if (!geometryCache.button) {
                    geometryCache.button = new THREE.BoxGeometry(BLOCK_SIZE * 0.4, BLOCK_SIZE * 0.1, BLOCK_SIZE * 0.4);
                    geometryCache.button.translate(0, -BLOCK_SIZE * 0.45, 0);
                }
                return geometryCache.button;
            }
            // Trapdoors
            if (blockName.includes('trapdoor')) {
                if (!geometryCache.trapdoor) {
                    geometryCache.trapdoor = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE * 0.1, BLOCK_SIZE);
                    geometryCache.trapdoor.translate(0, -BLOCK_SIZE * 0.45, 0);
                }
                return geometryCache.trapdoor;
            }
            // Default: full cube
            return getSharedCubeGeometry();
        }

        // --- CUSTOM UI FUNCTIONS ---
        function withElement(id, callback) {
            const el = document.getElementById(id);
            if (!el) {
                console.warn(`Element with id '${id}' not found in DOM.`);
                return null;
            }
            if (typeof callback === 'function') {
                callback(el);
            }
            return el;
        }
        function hideMessageBox() {
            withElement('messageBox', (el) => el.classList.add('hidden'));
        }
        if (typeof window !== 'undefined') {
            window.hideMessageBox = hideMessageBox;
        }

        function updatePackStatus(text) {
            withElement('packStatus', (el) => {
                el.textContent = text;
            });
        }

        function showMessage(title, text, isError = true) {
            const box = document.getElementById('messageBox');
            const titleEl = document.getElementById('messageTitle');
            const textEl = document.getElementById('messageText');
            const buttonEl = box ? box.querySelector('button') : null;

            if (!box || !titleEl || !textEl || !buttonEl) {
                console.warn("Message box elements are missing in the DOM.");
                return;
            }

            titleEl.textContent = title;
            textEl.innerHTML = text; 

            titleEl.classList.toggle('text-red-600', isError);
            titleEl.classList.toggle('text-indigo-600', !isError);
            buttonEl.classList.toggle('bg-red-500', isError);
            buttonEl.classList.toggle('hover:bg-red-600', isError);
            buttonEl.classList.toggle('bg-indigo-600', !isError);
            buttonEl.classList.toggle('hover:bg-indigo-700', !isError);
            
            box.classList.remove('hidden');
        }

        // --- 2D LAYER GRID VIEW LOGIC ---
        function render2DLayerGrid() {
            const canvas = document.getElementById('layer2d-canvas');
            if (!canvas || !structureData) return;
            const ctx = canvas.getContext('2d');
            const tooltip = document.getElementById('layer2d-tooltip');
            const info = document.getElementById('layer2dInfo');
            const layerInput = document.getElementById('layer2dInput');
            const { size, blocks, palette } = structureData;
            const sx = size.x, sz = size.z, sy = size.y;
            // high-DPI handling
            const dpr = window.devicePixelRatio || 1;
            // Ensure we draw in CSS pixels by scaling context
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            const cssW = canvas.width / dpr;
            const cssH = canvas.height / dpr;

            // Clamp layer
            let y = Math.max(0, Math.min(Number(layerInput.value) || 0, sy - 1));
            layerInput.value = y;
            info.textContent = `/ ${sy - 1}`;

            // Find blocks in this layer
            const grid = Array.from({ length: sz }, () => Array(sx).fill(null));
            blocks.forEach(b => { if (b.y === y) grid[b.z][b.x] = b; });

            // Scale to fit: use more padding but allow cells to be large
            const pad = 8;
            const cellW = Math.floor((cssW - 2 * pad) / sx);
            const cellH = Math.floor((cssH - 2 * pad) / sz);
            const drawW = cellW * sx, drawH = cellH * sz;
            const offX = Math.floor((cssW - drawW) / 2);
            const offY = Math.floor((cssH - drawH) / 2);

            // Clear and draw background
            ctx.clearRect(0, 0, cssW, cssH);

            // Draw grid cells and fill with textures if available
            ctx.save();
            ctx.lineWidth = 1;
            for (let z = 0; z < sz; z++) {
                for (let x = 0; x < sx; x++) {
                    // Center highlight
                    let isCenter = false;
                    if (sx % 2 === 1 && sz % 2 === 1) isCenter = (x === Math.floor(sx / 2) && z === Math.floor(sz / 2));
                    else if (sx % 2 === 0 && sz % 2 === 0) isCenter = (x === sx / 2 - 1 || x === sx / 2) && (z === sz / 2 - 1 || z === sz / 2);
                    else if (sx % 2 === 0) isCenter = (x === sx / 2 - 1 || x === sx / 2) && (z === Math.floor(sz / 2));
                    else if (sz % 2 === 0) isCenter = (z === sz / 2 - 1 || z === sz / 2) && (x === Math.floor(sx / 2));
                    ctx.fillStyle = isCenter ? '#e0e7ef' : '#f3f4f6';
                    const xPx = offX + x * cellW, yPx = offY + z * cellH;
                    ctx.fillRect(xPx, yPx, cellW, cellH);
                    ctx.strokeStyle = '#b6bbc7';
                    ctx.strokeRect(xPx + 0.5, yPx + 0.5, cellW - 1, cellH - 1);

                    // Draw texture preview if available
                    const b = grid[z][x];
                    if (b) {
                        const img = palettePreviewImages[b.paletteIndex];
                        if (img && img.complete && img.naturalWidth) {
                            // draw image to fit cell (cover style)
                            const iw = img.naturalWidth, ih = img.naturalHeight;
                            // calculate cover scaling
                            const scale = Math.max(cellW / iw, cellH / ih);
                            const dw = iw * scale, dh = ih * scale;
                            const dx = xPx + (cellW - dw) / 2;
                            const dy = yPx + (cellH - dh) / 2;
                            ctx.drawImage(img, dx, dy, dw, dh);
                        } else {
                            // fallback: color by block name
                            const paletteEntry = palette[b.paletteIndex];
                            ctx.save(); ctx.globalAlpha = 0.85;
                            ctx.fillStyle = stringToColor(paletteEntry?.name || 'unknown');
                            ctx.fillRect(xPx + 2, yPx + 2, cellW - 4, cellH - 4);
                            ctx.restore();
                        }
                    }
                }
            }
            ctx.restore();

            // Mouse interaction (in CSS pixel coords) - tooltip follows mouse but clamped inside wrapper
            // Throttle tooltip updates using requestAnimationFrame for smooth movement
            let pendingMouse = null;
            let rafId = null;
            canvas.onmousemove = e => { pendingMouse = e; if (!rafId) rafId = requestAnimationFrame(processMouse); };
            function processMouse() {
                rafId = null;
                const e = pendingMouse;
                pendingMouse = null;
                if (!e) return;
                const wrap = canvas.parentElement || document.getElementById('layer2d-canvas-wrap');
                const wrapRect = wrap.getBoundingClientRect();
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left, my = e.clientY - rect.top;
                const gx = Math.floor((mx - offX) / cellW), gz = Math.floor((my - offY) / cellH);
                if (gx >= 0 && gx < sx && gz >= 0 && gz < sz) {
                    const b = grid[gz][gx];
                    let html = `<b>Block:</b> `;
                    if (b) {
                        const p = palette[b.paletteIndex];
                        html += (p?.name || 'unknown').replace('minecraft:', '');
                        if (p?.states && Object.keys(p.states).length) {
                            html += `<br><b>Data:</b> ` + Object.entries(p.states).map(([k, v]) => `${k}: ${v}`).join(', ');
                        }
                    } else html += 'air';
                    html += `<br><b>Coords:</b> (${gx}, ${gz})`;
                    tooltip.innerHTML = html;
                    tooltip.style.display = 'block';

                    // Position next to mouse but clamp within wrapper
                    const ttRect = tooltip.getBoundingClientRect();
                    const margin = 8;
                    let left = e.clientX + 12;
                    let top = e.clientY + 12;
                    const maxLeft = wrapRect.right - ttRect.width - margin;
                    const minLeft = wrapRect.left + margin;
                    if (left > maxLeft) left = e.clientX - 12 - ttRect.width;
                    if (left < minLeft) left = minLeft;
                    const maxTop = wrapRect.bottom - ttRect.height - margin;
                    const minTop = wrapRect.top + margin;
                    if (top > maxTop) top = e.clientY - 12 - ttRect.height;
                    if (top < minTop) top = minTop;
                    tooltip.style.left = left + 'px';
                    tooltip.style.top = top + 'px';
                } else {
                    tooltip.style.display = 'none';
                }
            }
            canvas.onmouseleave = () => { pendingMouse = null; if (rafId) { cancelAnimationFrame(rafId); rafId = null; } tooltip.style.display = 'none'; };
            canvas.onmouseleave = () => { tooltip.style.display = 'none'; };
        }

        // Utility: deterministic color for block name
        function stringToColor(str) {
            let hash = 0; for (let i=0; i<str.length; i++) hash = str.charCodeAt(i) + ((hash<<5)-hash);
            const c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
            return '#'+('00000'.substring(0,6-c.length))+c;
        }

        // Hook up 2D grid to structure load and layer input
        function setup2DLayerGrid() {
            const input = document.getElementById('layer2dInput');
            if (!input) return;
            input.addEventListener('input', () => { render2DLayerGrid(); try { updateOverlayGrid(); } catch(e) {} });
        }

        // Call this after structureData is loaded
        function update2DLayerGridAfterLoad() {
            const input = document.getElementById('layer2dInput');
            if (!input || !structureData) return;
            input.min = 0;
            input.max = Math.max(0, structureData.size.y-1);
            input.value = Math.min(input.value, structureData.size.y-1);
            render2DLayerGrid();
        }

        // --- CORE APPLICATION FUNCTIONS ---

        /**
         * Calculates material counts, rounds them up to stacks, and displays the list.
         * @param {object} materials - A map of block ID to count.
         */
        async function displayMaterialList(materials) {
            console.log("Building Material List.");
            const listContainer = withElement('material-list', (el) => {
                el.innerHTML = '';
            });
            withElement('materialEmpty', (el) => el.classList.add('hidden'));

            const sortedMaterials = Object.entries(materials).sort(([, a], [, b]) => b - a);

            if (sortedMaterials.length === 0) {
                if (listContainer) {
                    listContainer.innerHTML = '<p class="text-sm text-gray-500">No solid blocks found in the structure data.</p>';
                }
                console.warn("Material list is empty.");
                return;
            }

            const materialEntries = await Promise.all(
                sortedMaterials.map(async ([id, count]) => {
                    let previewSrc = '';
                    try {
                        previewSrc = await textureManager.getBlockPreview(id);
                    } catch (error) {
                        console.warn(`Preview texture missing for ${id}`, error);
                    }
                    return { id, count, previewSrc };
                })
            );

            materialEntries.forEach(({ id, count, previewSrc }) => {
                const totalStacks = Math.ceil(count / STACK_SIZE);
                const stacksDisplay = `${totalStacks} stack${totalStacks !== 1 ? 's' : ''}`;
                const baseId = id.split(':')[1] || id;
                const displayName = baseId.replace(/_/g, ' ').toUpperCase();

                const listItem = document.createElement('div');
                listItem.className = 'flex justify-between items-center p-2 mb-2 bg-white rounded-md shadow-sm border border-gray-100';
                const thumbnail = previewSrc
                    ? `<img src="${previewSrc}" alt="${displayName} texture" />`
                    : `<span class="text-[10px] text-gray-400">N/A</span>`;

                listItem.innerHTML = `
                    <div class="flex items-center gap-3">
                        <div class="material-thumb">${thumbnail}</div>
                        <span class="font-medium text-gray-800">${displayName}</span>
                    </div>
                    <div class="text-right">
                        <span class="block text-sm font-bold text-indigo-600">${stacksDisplay}</span>
                        <span class="block text-xs text-gray-500">${count} blocks</span>
                    </div>
                `;
                if (listContainer) {
                    listContainer.appendChild(listItem);
                }
            });
            console.log(`Material list built with ${materialEntries.length} unique items.`);
        }

        /**
         * Initializes the Three.js scene, camera, and controls.
         */
        function initThreeJS() {
            const container = withElement('canvas-container');
            if (!container) return;
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Scene setup... (unchanged)
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.set(20, 20, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 100;

            scene.add(new THREE.AmbientLight(0x404040)); 
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);

            blockGroup = new THREE.Group();
            scene.add(blockGroup);

            if (!THREE.BufferGeometryUtils) {
                console.warn('THREE.BufferGeometryUtils is not available. Merging geometries will not work; consider adding the BufferGeometryUtils script.');
            }

            gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x444444);
            gridHelper.position.y = -BLOCK_SIZE / 2; 
            scene.add(gridHelper);

            window.addEventListener('resize', onWindowResize, false);
            console.log("Three.js environment initialized.");
        }

        /**
         * Resizes the Three.js renderer and camera.
         */
        function onWindowResize() {
            const container = withElement('canvas-container');
            if (!container) return;
            const width = container.clientWidth;
            const height = container.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        /**
         * The main render loop.
         */
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); 
            renderer.render(scene, camera);
        }

        /**
         * Draws all blocks from the structure data in 3D using resource-pack textures.
         * @param {object} data - The parsed structure data.
         */
        async function buildStructure(data) {
            console.log("Building 3D structure visualization.");
            while (blockGroup.children.length > 0) {
                blockGroup.remove(blockGroup.children[0]);
            }

            if (!data || !Array.isArray(data.blocks) || data.blocks.length === 0) {
                console.warn("No solid blocks available to visualize.");
                return;
            }

            const { blocks, size, palette } = data;
            const center = {
                x: (size.x - 1) * BLOCK_SIZE / 2,
                y: 0,
                z: (size.z - 1) * BLOCK_SIZE / 2
            };

            // geometry selection now per block type

            // Get visuals for the palette entries (defensive - preserve successes)
            const settled = await Promise.allSettled(palette.map((entry) => textureManager.getBlockVisual(entry)));
            const paletteVisuals = settled.map((res, idx) => (res.status === 'fulfilled' && res.value) ? res.value : textureManager.getFallbackVisual());

            // Diagnostic: log palette visuals to help detect when many entries map to 'air' or a missing texture
            try {
                const diag = paletteVisuals.map((v, i) => {
                    const mat = Array.isArray(v.materials) && v.materials[0] ? v.materials[0] : null;
                    const src = mat?.map?.userData?.sourcePath || mat?.userData?.sourcePath || mat?.map?.userData?.previewSrc || mat?.userData?.previewSrc || null;
                    return { index: i, id: (palette[i] && (palette[i].name || palette[i].block)) || JSON.stringify(palette[i]), src, materials: Array.isArray(v.materials) ? v.materials.length : (v.materials ? 1 : 0) };
                });
                // Expose a global diagnostic snapshot so the console can read it any time
                window._paletteVisuals = diag;
                // Also expose the full visual objects so we can inspect the actual materials and maps
                window._paletteVisualObjects = paletteVisuals;
                console.log('Palette visual sources (first 200):', diag.slice(0, 200));
            } catch (e) {
                console.warn('Palette diagnostic failed', e);
            }

            // InstancedMesh optimization: group blocks by paletteIndex
            let skippedAir = 0;
            let skippedOther = 0;
            let renderedBlocks = 0;
            const blockGroups = {};
            blocks.forEach((block) => {
                const paletteEntry = (palette && palette[block.paletteIndex]) || null;
                const entryName = (paletteEntry && paletteEntry.name) ? String(paletteEntry.name).toLowerCase() : '';
                if (!paletteEntry) {
                    skippedOther++;
                    return;
                }
                if (/(^|:)air$/.test(entryName)) {
                    skippedAir++;
                    return;
                }
                if (!blockGroups[block.paletteIndex]) blockGroups[block.paletteIndex] = [];
                blockGroups[block.paletteIndex].push(block);
            });

            Object.keys(blockGroups).forEach((paletteIndexStr) => {
                const paletteIndex = parseInt(paletteIndexStr, 10);
                const group = blockGroups[paletteIndex];
                if (!group || group.length === 0) return;
                const visual = paletteVisuals[paletteIndex] || textureManager.getFallbackVisual();
                let materials = Array.isArray(visual.materials) ? visual.materials.slice() : [];
                if (materials.length < 6) {
                    const fallback = textureManager.getFallbackVisual().materials[0];
                    while (materials.length < 6) materials.push(fallback);
                }
                // Use only the first material for instancing (Three.js limitation)
                const instMaterial = materials[0];
                // Select geometry for this block type
                const blockName = (palette[paletteIndex] && palette[paletteIndex].name) ? palette[paletteIndex].name : '';
                const instGeometry = getBlockGeometry(blockName);
                const mesh = new THREE.InstancedMesh(instGeometry, instMaterial, group.length);
                let i = 0;
                group.forEach((block) => {
                    const matrix = new THREE.Matrix4();
                    matrix.setPosition(
                        block.x * BLOCK_SIZE - center.x,
                        block.y * BLOCK_SIZE + BLOCK_SIZE / 2,
                        block.z * BLOCK_SIZE - center.z
                    );
                    mesh.setMatrixAt(i, matrix);
                    mesh.userData = { layer: block.y };
                    i++;
                    renderedBlocks++;
                });
                blockGroup.add(mesh);
            });
            console.log(`[DEBUG] buildStructure: Rendered blocks: ${renderedBlocks}, Skipped air: ${skippedAir}, Skipped other: ${skippedOther}, Total input blocks: ${blocks.length}`);
            if (skippedAir > 0) console.log(`Skipped creating ${skippedAir} air meshes during buildStructure.`);
            if (skippedOther > 0) console.log(`Skipped creating ${skippedOther} blocks due to missing palette entry.`);

            // Adjust grid size
            scene.remove(gridHelper);
            const gridRange = Math.max(size.x, size.z) * BLOCK_SIZE;
            gridHelper = new THREE.GridHelper(gridRange, gridRange, 0x444444, 0x444444);
            gridHelper.position.y = -BLOCK_SIZE / 2;
            gridHelper.visible = isGridVisible;
            scene.add(gridHelper);


            // Recenter camera view
            controls.target.set(0, size.y * BLOCK_SIZE / 2, 0);
            controls.update();
            console.log(`3D structure built. Dimensions: ${size.x}x${size.y}x${size.z}`);
            // Refresh overlay grid to match new structure
            try { updateOverlayGrid(); } catch (e) { /* ignore if not ready */ }
        }

        // Draw an overlay grid (thicker visual lines) at the currently selected layer and highlight center area
        function updateOverlayGrid() {
            if (!structureData || !scene) return;
            const layerInput = document.getElementById('layer2dInput');
            const y = layerInput ? Math.max(0, Math.min(Number(layerInput.value) || 0, structureData.size.y - 1)) : 0;
            currentLayer = y;
            // remove previous overlay group
            if (overlayGrid) {
                try {
                    overlayGrid.children.forEach(c => { overlayGrid.remove(c); c.geometry?.dispose(); c.material?.dispose(); });
                    scene.remove(overlayGrid);
                } catch (e) {}
                overlayGrid = null;
            }

            const sx = structureData.size.x, sz = structureData.size.z;
            const centerX = (sx - 1) * BLOCK_SIZE / 2;
            const centerZ = (sz - 1) * BLOCK_SIZE / 2;

            overlayGrid = new THREE.Group();

            // thicker line thickness implemented as thin box meshes (so they show up clearly)
            const lineThickness = 0.06 * BLOCK_SIZE; // tune this value for visibility
            const lineHeight = 0.02 * BLOCK_SIZE; // small vertical thickness

            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0x111827, transparent: true, opacity: 0.85 });

            // vertical lines along X
            for (let x = 0; x <= sx; x++) {
                const vx = x * BLOCK_SIZE - centerX - BLOCK_SIZE/2;
                const length = (sz + 0.0) * BLOCK_SIZE + lineThickness; // cover full Z
                const geom = new THREE.BoxGeometry(lineThickness, lineHeight, length);
                const mesh = new THREE.Mesh(geom, lineMaterial);
                mesh.position.set(vx, y * BLOCK_SIZE + lineHeight / 2 + 0.01, 0);
                overlayGrid.add(mesh);
            }

            // horizontal lines along Z
            for (let z = 0; z <= sz; z++) {
                const vz = z * BLOCK_SIZE - centerZ - BLOCK_SIZE/2;
                const length = (sx + 0.0) * BLOCK_SIZE + lineThickness;
                const geom = new THREE.BoxGeometry(length, lineHeight, lineThickness);
                const mesh = new THREE.Mesh(geom, lineMaterial);
                mesh.position.set(0, y * BLOCK_SIZE + lineHeight / 2 + 0.01, vz);
                overlayGrid.add(mesh);
            }

            // center area highlight: determine if 1-block centered or 2-block centered
            const centerArea = new THREE.Group();
            if (sx % 2 === 1 && sz % 2 === 1) {
                // single center cell
                const cx = Math.floor(sx / 2);
                const cz = Math.floor(sz / 2);
                const geom = new THREE.PlaneGeometry(BLOCK_SIZE, BLOCK_SIZE);
                const mat = new THREE.MeshBasicMaterial({ color: 0x2563eb, transparent: true, opacity: 0.12, side: THREE.DoubleSide });
                const plane = new THREE.Mesh(geom, mat);
                plane.rotation.x = -Math.PI/2;
                plane.position.set(cx * BLOCK_SIZE - centerX, y * BLOCK_SIZE + 0.015, cz * BLOCK_SIZE - centerZ);
                centerArea.add(plane);
            } else {
                // two-block centered area (2x1 or 2x2) - compute central indices
                const cxLow = Math.floor((sx - 1) / 2);
                const czLow = Math.floor((sz - 1) / 2);
                const cxCount = (sx % 2 === 0) ? 2 : 1;
                const czCount = (sz % 2 === 0) ? 2 : 1;
                const geom = new THREE.PlaneGeometry(BLOCK_SIZE * cxCount, BLOCK_SIZE * czCount);
                const mat = new THREE.MeshBasicMaterial({ color: 0x16a34a, transparent: true, opacity: 0.12, side: THREE.DoubleSide });
                const plane = new THREE.Mesh(geom, mat);
                plane.rotation.x = -Math.PI/2;
                const centerCellX = (cxLow + (cxCount - 1) / 2) * BLOCK_SIZE - centerX;
                const centerCellZ = (czLow + (czCount - 1) / 2) * BLOCK_SIZE - centerZ;
                plane.position.set(centerCellX, y * BLOCK_SIZE + 0.015, centerCellZ);
                centerArea.add(plane);
            }
            overlayGrid.add(centerArea);

            scene.add(overlayGrid);
        }

        /**
         * Filters the 3D visualization to show only blocks between bottom and top (inclusive).
         * If filtering is disabled, all blocks will be shown.
         * @param {number} bottom - minimum layer index to display
         * @param {number} top - maximum layer index to display
         */
        function applyLayerRange(bottom, top) {
            // Clamp and normalize
            bottom = Math.max(0, Number.isFinite(bottom) ? bottom : 0);
            top = Math.min(maxLayer, Number.isFinite(top) ? top : maxLayer);
            if (bottom > top) {
                // swap to be tolerant
                const tmp = bottom; bottom = top; top = tmp;
            }

            const enabledEl = document.getElementById('enableLayerFilter');
            const enabled = enabledEl ? enabledEl.checked : true;

            withElement('currentLayerDisplay', (el) => {
                el.textContent = enabled ? `${bottom} - ${top}` : 'All';
            });

            if (!blockGroup || !blockGroup.children) return;

            blockGroup.children.forEach(mesh => {
                const layer = mesh.userData.layer;
                mesh.visible = enabled ? (layer >= bottom && layer <= top) : true;
            });

            // Quick diagnostic: if only a small range is shown, log a summary of distinct material sources
            if (enabled && (top - bottom) <= 1) {
                const sourceMap = new Map();
                let visibleCount = 0;
                blockGroup.children.forEach(mesh => {
                    if (!mesh.visible) return;
                    visibleCount++;
                    const mats = mesh.material || [];
                    (Array.isArray(mats) ? mats : [mats]).forEach(m => {
                        const tex = m?.map;
                        const src = tex?.userData?.sourcePath || m?.userData?.sourcePath || tex?.userData?.previewSrc || m?.userData?.previewSrc || null;
                        const key = src || '__no_src__';
                        if (!sourceMap.has(key)) {
                            sourceMap.set(key, { count: 0, sample: tex || m });
                        }
                        sourceMap.get(key).count += 1;
                    });
                });

                const summary = [];
                for (const [src, info] of sourceMap.entries()) {
                    const sample = info.sample;
                    const tex = sample?.map || sample;
                    const img = tex?.image;
                    const width = img?.width || img?.naturalWidth || (img && img.width) || null;
                    const height = img?.height || img?.naturalHeight || (img && img.height) || null;
                    const resized = tex?.userData?.resized || false;
                    const preview = tex?.userData?.previewSrc || sample?.userData?.previewSrc || null;
                    summary.push({ src: src === '__no_src__' ? null : src, count: info.count, width, height, resized, preview });
                }

                console.log(`Layer range filter applied: ${enabled ? `${bottom}..${top}` : 'All'}. Visible meshes: ${visibleCount}. Texture source summary (first 50):`, summary.slice(0,50));
            } else {
                console.log(`Layer range filter applied: ${enabled ? `${bottom}..${top}` : 'All'}`);
            }
        }

        // --- EVENT HANDLERS ---

        /**
         * Main entry point for file processing.
         * Calls the external parseMCStructureBinary function.
         */
        async function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            console.log(`Starting file processing for: ${file.name} (${file.size} bytes)`);

            const fileInputEl = document.getElementById('fileInput');
            if (fileInputEl) fileInputEl.value = '';
            const loadingMessageEl = document.getElementById('loadingMessage');
            if (loadingMessageEl) {
                loadingMessageEl.classList.remove('hidden');
            } else {
                console.warn("#loadingMessage element not found in DOM.");
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                console.log("FileReader completed reading file into ArrayBuffer.");
                try {
                    const buffer = e.target.result;
                    
                    // Call the dedicated parsing module
                    structureData = await parseMCStructureBinary(buffer);
                    // Expose last parsed structure for debugging in the console
                    try { window._lastStructureData = structureData; } catch (e) { /* ignore */ }

                    // Update global state based on parsed data
                    maxLayer = Math.max(structureData.size.y - 1, 0);

                    await displayMaterialList(structureData.materials);

                    // Initialize layer controls (bottom/top) and default to first layer only to avoid lag
                    const bottomInput = document.getElementById('layerBottomInput');
                    const topInput = document.getElementById('layerTopInput');
                    const enableFilter = document.getElementById('enableLayerFilter');
                    const layerControls = document.getElementById('layerControls');


                    if (bottomInput && topInput) {
                        bottomInput.min = 0;
                        bottomInput.max = maxLayer;
                        topInput.min = 0;
                        topInput.max = maxLayer;

                        // Default to show all layers
                        bottomInput.value = 0;
                        topInput.value = maxLayer;
                    } else {
                        console.warn("Layer input elements not found in DOM.");
                    }

                    if (enableFilter) {
                        // Show all layers by default (filter off)
                        enableFilter.checked = false;
                    }

                    if (layerControls) {
                        layerControls.classList.remove('hidden');
                    }


                    // Preload palette preview images for 2D view
                    try {
                        const promises = (structureData.palette || []).map(async (p, idx) => {
                            try {
                                const src = await textureManager.getBlockPreview(p.name || p.block || '');
                                if (src) {
                                    const img = new Image();
                                    img.src = src;
                                    palettePreviewImages[idx] = img;
                                }
                            } catch (e) {
                                // ignore missing previews
                            }
                        });
                        await Promise.all(promises);
                    } catch (e) {
                        console.warn('Failed to preload palette previews', e);
                    }

                    // Size the 2D canvas now that we know structure dimensions and previews
                    try { if (typeof window.sizeLayer2DCanvas === 'function') window.sizeLayer2DCanvas(); } catch(e) {}
                    // Update 2D grid view
                    update2DLayerGridAfterLoad();

                    await buildStructure(structureData);

                    // Apply the default layer range (show only first layer)
                    const b = bottomInput ? parseInt(bottomInput.value, 10) : 0;
                    const t = topInput ? parseInt(topInput.value, 10) : 0;
                    applyLayerRange(b, t);

                    // Auto-enable Preview Mode (no lighting) so textures are visible by default
                    try {
                        const previewCheckbox = document.getElementById('previewModeCheckbox');
                        if (previewCheckbox && !previewCheckbox.checked) {
                            previewCheckbox.checked = true;
                            previewCheckbox.dispatchEvent(new Event('change'));
                        }
                    } catch (e) {
                        console.warn('Failed to auto-enable Preview Mode', e);
                    }
                    
                    if (loadingMessageEl) {
                        loadingMessageEl.classList.add('hidden');
                    }
                    const emptyStateEl = document.getElementById('emptyState');
                    if (emptyStateEl) {
                        emptyStateEl.classList.add('hidden');
                    }
                    showMessage("Parsing Complete", 
                        `The structure **${file.name}** was parsed successfully.
                        <p class="text-left mt-3">The viewport now shows official Bedrock block textures (with orientation-aware faces), and the material list displays the same textures with stack counts rounded up to 64.</p>`, 
                        false);

                } catch (error) {
                    if (loadingMessageEl) {
                        loadingMessageEl.classList.add('hidden');
                    }
                    const emptyStateEl = document.getElementById('emptyState');
                    if (emptyStateEl) {
                        emptyStateEl.classList.remove('hidden');
                    }

                    console.error("Critical File Processing Error:", error);
                    const errorMessage = `The file **${file.name}** failed to load.
                    
                    <p class="text-left mt-3">**Reason:** ${error.message}</p>
                    <p class="text-left mt-3">This error means your file is likely corrupted or not a recognized Bedrock structure format. Check the console logs for the exact step failure (Gzip Decompression or NBT Format Check).</p>
                    `;
                    showMessage("Structure File Error", errorMessage, true);
                }
            };
            
            reader.onerror = (e) => {
                console.error("FileReader Error:", e);
                withElement('loadingMessage', (el) => el.classList.add('hidden'));
                showMessage("File Read Error", "The browser could not read the file. This might be due to file permissions or corruption.", true);
            };

            reader.readAsArrayBuffer(file);
        }

        async function handleResourcePackUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            console.log(`Starting resource pack load for: ${file.name} (${file.size} bytes)`);
            try {
                await textureManager.setZipFile(file);
                updatePackStatus(`Textures: ${file.name}`);
                showMessage(
                    "Resource Pack Loaded",
                    `Successfully loaded **${file.name}**. Future visualizations will use its textures.`,
                    false
                );
            } catch (error) {
                console.error("Resource pack load failed:", error);
                showMessage(
                    "Resource Pack Error",
                    `Unable to load **${file.name}**.<p class="text-left mt-3">${error.message}</p>`,
                    true
                );
            } finally {
                event.target.value = '';
            }
        }

        // --- INITIALIZATION ---
        window.onload = function () {

            // 2D Layer Grid setup
            setup2DLayerGrid();

            // Helper to size the 2D canvas to its container and account for devicePixelRatio
            function sizeLayer2DCanvas() {
                const canvas = document.getElementById('layer2d-canvas');
                const wrap = document.getElementById('layer2d-canvas-wrap');
                if (!canvas || !wrap) return;
                // Compute CSS size as 80% of wrap width and keep a square aspect ratio
                const cssWidth = Math.max(160, Math.min(Math.floor(wrap.clientWidth * 0.8), window.innerWidth * 0.9));
                const cssHeight = cssWidth; // keep square for top-down view
                // device pixel ratio for crisp rendering
                const dpr = window.devicePixelRatio || 1;
                canvas.style.width = cssWidth + 'px';
                canvas.style.height = cssHeight + 'px';
                canvas.width = Math.floor(cssWidth * dpr);
                canvas.height = Math.floor(cssHeight * dpr);
                // Ensure the context transform is reset by render2DLayerGrid which sets transform
                render2DLayerGrid();
            }

            // Size on load and on resize
            window.addEventListener('resize', () => {
                sizeLayer2DCanvas();
            });

            // Also expose sizing so other code can call it after structure loads
            window.sizeLayer2DCanvas = sizeLayer2DCanvas;

            // Initial sizing
            sizeLayer2DCanvas();

            console.log("Application started. Initializing Three.js.");
            initThreeJS();
            animate();
            updatePackStatus(DEFAULT_PACK_STATUS);

            // Expose live references to module-scoped internals for debugging in the console
            window._app = {
                get scene() { return scene; },
                get camera() { return camera; },
                get renderer() { return renderer; },
                get controls() { return controls; },
                get blockGroup() { return blockGroup; },
                get textureManager() { return textureManager; }
            };

            // Helper to dump blockGroup mesh/material summary from the console: call window.dumpBlockGroupSummary()
            window.dumpBlockGroupSummary = function() {
                const bg = window._app.blockGroup;
                if (!bg) { console.warn('blockGroup not ready'); return; }
                bg.children.forEach((mesh, meshIdx) => {
                    const mats = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
                    const matInfo = mats.map((m, i) => ({
                        matIndex: i,
                        hasMap: !!(m && m.map),
                        mapImageSize: m && m.map && (m.map.image?.naturalWidth || m.map.image?.width) || null,
                        sourcePath: m?.map?.userData?.sourcePath || m?.userData?.sourcePath || null,
                        previewSrcPresent: !!(m?.map?.userData?.previewSrc || m?.userData?.previewSrc)
                    }));
                    console.log(`Mesh[${meshIdx}] layer=${mesh.userData?.layer} materials=${mats.length}`, matInfo);
                });
            };

            // Inspect the last parsed structure blocks for diagnostics
            window.inspectStructureBlocks = function() {
                const data = window._lastStructureData;
                if (!data) { console.warn('No structure data available (load a file first).'); return; }
                const totalBlocks = Array.isArray(data.blocks) ? data.blocks.length : 0;
                const byPalette = {};
                const byLayer = {};
                (data.blocks || []).forEach(b => {
                    byPalette[b.paletteIndex] = (byPalette[b.paletteIndex] || 0) + 1;
                    byLayer[b.y] = (byLayer[b.y] || 0) + 1;
                });
                console.log('Structure summary: size=', data.size, 'totalBlocks=', totalBlocks);
                console.log('Blocks by palette index (first 50):', Object.entries(byPalette).slice(0,50));
                console.log('Blocks by Y layer (first 50):', Object.entries(byLayer).slice(0,50));
            };

            // Expose a helper to dump the palette visuals (which textures each palette entry resolved to)
            window.dumpPaletteVisuals = function() {
                const diag = window._paletteVisuals;
                if (Array.isArray(diag) && diag.length > 0) {
                    diag.forEach(d => console.log(`Palette[${d.index}] id=${d.id} -> ${d.src} (materials:${d.materials})`));
                    console.log('paletteVisuals length:', diag.length);
                    return;
                }
                // Fallback: try to print a simple view by inspecting palette and attempting to compute srcs
                if (!Array.isArray(palette)) { console.warn('Palette not available to recompute visuals'); return; }
                palette.forEach((p, i) => {
                    console.log(`Palette[${i}] id=${(p && (p.name || p.block)) || JSON.stringify(p)} -> (no diagnostic cached)`);
                });
                console.log('No cached palette visuals available (call after a successful buildStructure to generate _paletteVisuals).');
            };

            window.dumpPaletteMaterialMaps = function() {
                const visuals = window._paletteVisualObjects;
                if (!Array.isArray(visuals) || visuals.length === 0) {
                    console.warn('No paletteVisualObjects cached; call buildStructure first.');
                    return;
                }
                visuals.forEach((v, i) => {
                    const mats = Array.isArray(v.materials) ? v.materials : [v.materials];
                    const matInfo = mats.map((m, idx) => ({
                        matIndex: idx,
                        hasMap: !!(m && m.map),
                        mapImageSize: m && m.map && (m.map.image?.naturalWidth || m.map.image?.width) || null,
                        sourcePath: m?.map?.userData?.sourcePath || m?.userData?.sourcePath || null
                    }));
                    console.log(`PaletteVisual[${i}] materials=${mats.length}`, matInfo);
                });
                console.log('paletteVisualObjects length:', visuals.length);
            };

            // Spawn a small textured probe cube in front of the camera using the first available loaded texture.
            // Use this when visible meshes don't have maps or are invisible to verify textures render.
            window.spawnTextureProbe = function() {
                const app = window._app || {};
                const sceneLocal = app.scene;
                const cameraLocal = app.camera;
                const texManager = app.textureManager;
                if (!sceneLocal || !cameraLocal) { console.warn('Scene or camera not available'); return; }

                // Remove previous probe
                const prev = sceneLocal.getObjectByName('textureProbe');
                if (prev) {
                    sceneLocal.remove(prev);
                    try { prev.geometry?.dispose(); } catch(e) {}
                    try { prev.material?.dispose(); } catch(e) {}
                }

                let tex = null;
                if (Array.isArray(window._paletteVisualObjects)) {
                    for (const v of window._paletteVisualObjects) {
                        const mats = Array.isArray(v.materials) ? v.materials : [v.materials];
                        for (const m of mats) {
                            if (m && m.map) { tex = m.map; break; }
                        }
                        if (tex) break;
                    }
                }

                if (!tex && texManager && texManager.textureCache) {
                    for (const t of texManager.textureCache.values()) {
                        if (t) { tex = t; break; }
                    }
                }

                if (!tex) { console.warn('No loaded texture found to spawn probe.'); return; }

                const dir = new THREE.Vector3();
                cameraLocal.getWorldDirection(dir);
                const pos = cameraLocal.position.clone().add(dir.multiplyScalar(5));

                const geom = new THREE.BoxGeometry(1,1,1);
                const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
                const probe = new THREE.Mesh(geom, mat);
                probe.name = 'textureProbe';
                probe.position.copy(pos);
                sceneLocal.add(probe);
                if (app.controls && typeof app.controls.target !== 'undefined') {
                    app.controls.target.copy(probe.position);
                    app.controls.update();
                }
                console.log('Spawned texture probe using', tex.userData?.sourcePath || '(unknown)');
            };

            // FIX: Attach event listener programmatically since we are using 'type="module"'
            const fileInput = document.getElementById('fileInput');
            if (fileInput) {
                fileInput.addEventListener('change', handleFileSelect);
            } else {
                console.warn("#fileInput element not found in DOM.");
            }

            const resourcePackInput = document.getElementById('resourcePackInput');
            if (resourcePackInput) {
                resourcePackInput.addEventListener('change', handleResourcePackUpload);
            } else {
                console.warn("#resourcePackInput element not found in DOM.");
            }

            // Layer range controls
            const bottomInput = document.getElementById('layerBottomInput');
            const topInput = document.getElementById('layerTopInput');
            const enableFilter = document.getElementById('enableLayerFilter');
            const showAllBtn = document.getElementById('showAllLayers');
            const previewModeCheckbox = document.getElementById('previewModeCheckbox');

            // Preview Mode state storage for restoring original materials
            window._previewModeState = window._previewModeState || { enabled: false, originalMaterials: new WeakMap() };

            function enablePreviewMode() {
                const bg = window._app?.blockGroup;
                if (!bg) return;
                window._previewModeState.enabled = true;
                bg.children.forEach(mesh => {
                    if (!mesh.visible) return;
                    const mats = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
                    // store original materials once
                    if (!window._previewModeState.originalMaterials.has(mesh)) {
                        window._previewModeState.originalMaterials.set(mesh, mesh.material);
                    }
                    const newMats = mats.map(m => {
                        const map = m?.map || null;
                        return map ? new THREE.MeshBasicMaterial({ map: map, side: THREE.DoubleSide, transparent: m.transparent || false }) : new THREE.MeshBasicMaterial({ color: 0x999999 });
                    });
                    mesh.material = Array.isArray(mesh.material) ? newMats : newMats[0];
                });
                console.log('Preview Mode enabled: replaced visible meshes with MeshBasicMaterial.');
            }

            function disablePreviewMode() {
                const bg = window._app?.blockGroup;
                if (!bg) return;
                window._previewModeState.enabled = false;
                bg.children.forEach(mesh => {
                    if (!window._previewModeState.originalMaterials.has(mesh)) return;
                    const orig = window._previewModeState.originalMaterials.get(mesh);
                    mesh.material = orig;
                    window._previewModeState.originalMaterials.delete(mesh);
                });
                console.log('Preview Mode disabled: restored original materials for meshes.');
            }

            if (previewModeCheckbox) {
                previewModeCheckbox.addEventListener('change', () => {
                    if (previewModeCheckbox.checked) {
                        enablePreviewMode();
                        // also reveal all layers for the preview to be comprehensive
                        try { document.getElementById('showAllLayers')?.click(); } catch(e) {}
                    } else {
                        disablePreviewMode();
                    }
                });
            }

            function onLayerInputsChanged() {
                const bottom = bottomInput ? parseInt(bottomInput.value, 10) : 0;
                const top = topInput ? parseInt(topInput.value, 10) : maxLayer;
                applyLayerRange(bottom, top);
            }

            if (bottomInput) bottomInput.addEventListener('input', onLayerInputsChanged);
            if (topInput) topInput.addEventListener('input', onLayerInputsChanged);
            if (enableFilter) enableFilter.addEventListener('change', onLayerInputsChanged);
            if (showAllBtn) {
                showAllBtn.addEventListener('click', () => {
                    if (enableFilter) enableFilter.checked = false;
                    // reveal all
                    applyLayerRange(0, maxLayer);
                });
            }

            const toggleGridButton = document.getElementById('toggleGrid');
            if (toggleGridButton) {
                toggleGridButton.addEventListener('click', () => {
                    isGridVisible = !isGridVisible;
                    if (gridHelper) {
                        gridHelper.visible = isGridVisible;
                    }
                    toggleGridButton.textContent = isGridVisible ? 'Hide Grid' : 'Show Grid';
                    console.log(`Grid visibility toggled to: ${isGridVisible}`);
                });
            } else {
                console.warn("#toggleGrid element not found in DOM.");
            }
        };
    </script>
</body>
</html>