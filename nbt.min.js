
const TAG_END = 0;
const TAG_BYTE = 1;
const TAG_SHORT = 2;
const TAG_INT = 3;
const TAG_LONG = 4;
const TAG_FLOAT = 5;
const TAG_DOUBLE = 6;
const TAG_BYTE_ARRAY = 7;
const TAG_STRING = 8;
const TAG_LIST = 9;
const TAG_COMPOUND = 10;
const TAG_INT_ARRAY = 11;
const TAG_LONG_ARRAY = 12;

class LittleEndianNBTReader {
    constructor(input) {
        if (input instanceof ArrayBuffer) {
            this.buffer = input;
            this.byteOffset = 0;
            this.byteLength = input.byteLength;
        } else if (ArrayBuffer.isView(input)) {
            this.buffer = input.buffer;
            this.byteOffset = input.byteOffset;
            this.byteLength = input.byteLength;
        } else {
            throw new Error("NBT parser expects an ArrayBuffer or TypedArray.");
        }
        this.view = new DataView(this.buffer, this.byteOffset, this.byteLength);
        this.offset = 0;
        this.littleEndian = true;
        this.textDecoder = new TextDecoder("utf-8");
    }

    readUint8() {
        const value = this.view.getUint8(this.offset);
        this.offset += 1;
        return value;
    }

    readInt8() {
        const value = this.view.getInt8(this.offset);
        this.offset += 1;
        return value;
    }

    readInt16() {
        const value = this.view.getInt16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
    }

    readInt32() {
        const value = this.view.getInt32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
    }

    readFloat32() {
        const value = this.view.getFloat32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
    }

    readFloat64() {
        const value = this.view.getFloat64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
    }

    readBigInt64() {
        const value = this.view.getBigInt64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
    }

    readBytes(length) {
        const bytes = new Uint8Array(this.view.buffer, this.view.byteOffset + this.offset, length);
        this.offset += length;
        return bytes;
    }

    readString() {
        const length = this.view.getUint16(this.offset, this.littleEndian);
        this.offset += 2;
        if (length === 0) return "";
        const bytes = this.readBytes(length);
        return this.textDecoder.decode(bytes);
    }

    readTagPayload(tagType) {
        switch (tagType) {
            case TAG_BYTE:
                return this.readInt8();
            case TAG_SHORT:
                return this.readInt16();
            case TAG_INT:
                return this.readInt32();
            case TAG_LONG:
                return this.readBigInt64();
            case TAG_FLOAT:
                return this.readFloat32();
            case TAG_DOUBLE:
                return this.readFloat64();
            case TAG_BYTE_ARRAY: {
                const length = this.readInt32();
                const bytes = this.readBytes(length);
                return Array.from(bytes, (b) => (b << 24) >> 24); // convert to signed
            }
            case TAG_STRING:
                return this.readString();
            case TAG_LIST: {
                const childType = this.readUint8();
                const length = this.readInt32();
                const list = new Array(length);
                for (let i = 0; i < length; i++) {
                    list[i] = this.readTagPayload(childType);
                }
                return list;
            }
            case TAG_COMPOUND:
                return this.readCompound();
            case TAG_INT_ARRAY: {
                const length = this.readInt32();
                const arr = new Array(length);
                for (let i = 0; i < length; i++) {
                    arr[i] = this.readInt32();
                }
                return arr;
            }
            case TAG_LONG_ARRAY: {
                const length = this.readInt32();
                const arr = new Array(length);
                for (let i = 0; i < length; i++) {
                    arr[i] = this.readBigInt64();
                }
                return arr;
            }
            default:
                throw new Error(`Unsupported NBT tag type: ${tagType}`);
        }
    }

    readCompound() {
        const result = {};
        while (true) {
            const tagType = this.readUint8();
            if (tagType === TAG_END) {
                break;
            }
            const name = this.readString();
            result[name] = this.readTagPayload(tagType);
        }
        return result;
    }
}

function parseNBT(buffer) {
    console.log("NBT.js: Starting full NBT parsing...");
    const reader = new LittleEndianNBTReader(buffer);
    const rootType = reader.readUint8();
    if (rootType !== TAG_COMPOUND) {
        throw new Error("Root tag of NBT data must be a Compound.");
    }
    const rootName = reader.readString(); // Bedrock files usually have an empty root name.
    const data = reader.readCompound();
    console.log(`NBT.js: Parsed Compound root '${rootName}' with keys: ${Object.keys(data).join(', ')}`);
    return data;
}

const NBT = { parse: parseNBT };

if (typeof window !== "undefined") {
    window.NBT = NBT;
}

export { NBT };
export default NBT;

